name: Firebase Deploy

on:
  push:
    branches:
      - master
      - main
      - dev
      - development
  pull_request:
    branches:
      - master
      - main

jobs:
  build_and_deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest

    env:
      NODE_VERSION: '18'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup PNPM
        uses: pnpm/action-setup@v2
        with:
          version: 7.33.7
          run_install: false

      - name: Set up Node.js ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Determine environment
        id: determine_env
        run: |
          if [[ "${{ github.event_name }}" == "push" && ("${{ github.ref }}" == "refs/heads/master" || "${{ github.ref }}" == "refs/heads/main") ]]; then
            echo "ENVIRONMENT=production" >> $GITHUB_ENV
            echo "Using PRODUCTION environment"
            echo "envkeys=PROD_envKeys" >> $GITHUB_OUTPUT
            echo "service_account=PROD_FIREBASE_SERVICE_ACCOUNT" >> $GITHUB_OUTPUT
            echo "project_id=${{ secrets.PROD_FIREBASE_PROJECT_ID }}" >> $GITHUB_ENV
            echo "recaptcha_site_key=${{ secrets.PROD_RECAPTCHA_SITE_KEY }}" >> $GITHUB_ENV
            echo "recaptcha_secret_key=${{ secrets.PROD_RECAPTCHA_SECRET_KEY }}" >> $GITHUB_ENV
            echo "FIREBASE_REGION=us-central1" >> $GITHUB_ENV
            echo "DEPLOY_ENV=prod" >> $GITHUB_ENV
            echo "PROJECT=production" >> $GITHUB_ENV
            echo "PROJECT_ID=${{ secrets.PROD_FIREBASE_PROJECT_ID }}" >> $GITHUB_ENV
          else
            echo "ENVIRONMENT=development" >> $GITHUB_ENV
            echo "Using DEVELOPMENT environment"
            echo "envkeys=DEV_envKeys" >> $GITHUB_OUTPUT
            echo "service_account=DEV_FIREBASE_SERVICE_ACCOUNT" >> $GITHUB_OUTPUT
            echo "project_id=${{ secrets.DEV_FIREBASE_PROJECT_ID }}" >> $GITHUB_ENV
            echo "recaptcha_site_key=${{ secrets.DEV_RECAPTCHA_SITE_KEY }}" >> $GITHUB_ENV
            echo "recaptcha_secret_key=${{ secrets.DEV_RECAPTCHA_SECRET_KEY }}" >> $GITHUB_ENV
            echo "FIREBASE_REGION=us-central1" >> $GITHUB_ENV
            echo "DEPLOY_ENV=dev" >> $GITHUB_ENV
            echo "PROJECT=development" >> $GITHUB_ENV
            echo "PROJECT_ID=${{ secrets.DEV_FIREBASE_PROJECT_ID }}" >> $GITHUB_ENV
          fi

      # Set up Google Cloud authentication with simplified approach
      - name: Authenticate to Google Cloud
        id: auth
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ env.PROJECT == 'production'
            && secrets.PROD_FIREBASE_SERVICE_ACCOUNT
            || secrets.DEV_FIREBASE_SERVICE_ACCOUNT }}
          create_credentials_file: true
          export_environment_variables: true

      # Configure gcloud CLI with necessary roles for service usage
      - name: Set up Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          version: '461.0.0'
          project_id: ${{ env.PROJECT_ID }}

      # Set environment variables
      - name: Set environment variables
        run: |
          # Set the Google Application Credentials to the file created by the auth step
          echo "GOOGLE_APPLICATION_CREDENTIALS=${{ steps.auth.outputs.credentials_file_path }}" >> $GITHUB_ENV

          # Create a symbolic link to service-account.json for compatibility with existing code
          ln -sf ${{ steps.auth.outputs.credentials_file_path }} service-account.json
          echo "Created symbolic link from ${{ steps.auth.outputs.credentials_file_path }} to service-account.json"

          # Decode environment variables from GitHub secret and write to .env file
          echo "${{ secrets[steps.determine_env.outputs.envkeys] }}" | base64 --decode > .env
          echo "Created environment file from ${{ steps.determine_env.outputs.envkeys }}"

          # Add additional required environment variables
          echo "NUXT_PUBLIC_RECAPTCHA_SITE_KEY=$recaptcha_site_key" >> .env
          echo "RECAPTCHA_SECRET_KEY=$recaptcha_secret_key" >> .env
          echo "DEPLOY_ENV=$DEPLOY_ENV" >> .env
          echo "GOOGLE_APPLICATION_CREDENTIALS=$(pwd)/service-account.json" >> .env
          echo "FIREBASE_REGION=$FIREBASE_REGION" >> .env

          # Save Firebase configuration environment variables for build
          {
            echo "FIREBASE_API_KEY=${{ secrets.FIREBASE_API_KEY }}"
            echo "FIREBASE_AUTH_DOMAIN=${{ secrets.FIREBASE_AUTH_DOMAIN }}"
            echo "FIREBASE_PROJECT_ID=$project_id"
            echo "FIREBASE_STORAGE_BUCKET=${{ secrets.FIREBASE_STORAGE_BUCKET }}"
            echo "FIREBASE_MESSAGING_SENDER_ID=${{ secrets.FIREBASE_MESSAGING_SENDER_ID }}"
            echo "FIREBASE_APP_ID=${{ secrets.FIREBASE_APP_ID }}"
            echo "FIREBASE_MEASUREMENT_ID=${{ secrets.FIREBASE_MEASUREMENT_ID }}"
          } >> .env

          # For troubleshooting - Print environment file without sensitive values
          echo "Environment file created with the following keys:"
          grep -v "KEY\|SECRET\|PASSWORD\|TOKEN" .env | sed 's/=.*/=***/' || echo "No non-sensitive keys found"

          # Make sure .env file exists and has content
          if [ -s .env ]; then
            echo "âœ… Environment file created successfully with content"
          else
            echo "âŒ Environment file is empty or not created"
            exit 1
          fi

      # Try to enable required APIs before deployment (may fail if permissions insufficient)
      - name: Enable required Google Cloud APIs
        continue-on-error: true
        run: |
          echo "Attempting to enable required Google Cloud APIs for project ${{ env.PROJECT_ID }}..."

          gcloud services enable firebase.googleapis.com --project ${{ env.PROJECT_ID }} || echo "Could not enable firebase.googleapis.com - may already be enabled"
          gcloud services enable cloudbuild.googleapis.com --project ${{ env.PROJECT_ID }} || echo "Could not enable cloudbuild.googleapis.com - may already be enabled"
          gcloud services enable artifactregistry.googleapis.com --project ${{ env.PROJECT_ID }} || echo "Could not enable artifactregistry.googleapis.com - may already be enabled"
          gcloud services enable run.googleapis.com --project ${{ env.PROJECT_ID }} || echo "Could not enable run.googleapis.com - may already be enabled"
          gcloud services enable containerregistry.googleapis.com --project ${{ env.PROJECT_ID }} || echo "Could not enable containerregistry.googleapis.com - may already be enabled"

          echo "API enabling step complete"

      - name: Check package.json for Font Awesome dependencies
        id: check_fa
        run: |
          if grep -q "@fortawesome/fontawesome-pro" package.json; then
            echo "HAS_FA_PRO=true" >> $GITHUB_OUTPUT
            echo "Found Font Awesome Pro dependency in package.json"
          else
            echo "HAS_FA_PRO=false" >> $GITHUB_OUTPUT
            echo "No Font Awesome Pro dependency found, using public packages only"
          fi

      - name: Install dependencies
        run: |
          # Only configure FontAwesome Pro registry if needed
          if [[ "${{ steps.check_fa.outputs.HAS_FA_PRO }}" == "true" && -n "${{ secrets.FONTAWESOME_NPM_TOKEN }}" ]]; then
            echo "Configuring Font Awesome Pro registry"
            echo "@fortawesome:registry=https://npm.fontawesome.com/" > .npmrc
            echo "//npm.fontawesome.com/:_authToken=${{ secrets.FONTAWESOME_NPM_TOKEN }}" >> .npmrc
          else
            # Create a simple .npmrc that uses public registry for all packages
            echo "registry=https://registry.npmjs.org/" > .npmrc
            echo "Using public npm registry for all packages"
          fi

          # Install dependencies without Font Awesome Pro if token is missing
          if [[ "${{ steps.check_fa.outputs.HAS_FA_PRO }}" == "true" && -z "${{ secrets.FONTAWESOME_NPM_TOKEN }}" ]]; then
            echo "âš ï¸ Font Awesome Pro dependencies found but no token provided, installing without Pro packages"
            # Create a temporary package.json without FA Pro
            cat package.json | grep -v "@fortawesome/fontawesome-pro" > package.json.tmp
            mv package.json.tmp package.json
          fi

          # Install dependencies
          echo "Installing dependencies..."
          pnpm install --frozen-lockfile

          # Install vue-recaptcha-v3 if needed and not included in dependencies
          if ! grep -q "vue-recaptcha-v3" package.json; then
            pnpm add vue-recaptcha-v3
            echo "Added vue-recaptcha-v3 to dependencies"
          fi

      # Run nuxt prepare AFTER dependencies are installed
      - name: Run Nuxt prepare
        run: |
          echo "Running nuxt prepare after dependencies are installed and service account is available"
          # Verify the service account file is accessible
          echo "Service account file path: $GOOGLE_APPLICATION_CREDENTIALS"
          ls -l $GOOGLE_APPLICATION_CREDENTIALS

          # Run nuxt prepare
          pnpm nuxt prepare || pnpm exec nuxt prepare

      - name: Verify Firebase configuration
        run: |
          echo "Verifying Firebase configuration in config/firebase.config.js"
          cat config/firebase.config.js

          # Check if firebase.config.js uses environment variables
          if grep -q "process.env" config/firebase.config.js; then
            echo "âœ… Firebase config uses environment variables as required"
          else
            echo "âš ï¸ Firebase config might not be using environment variables - please verify the code"
          fi

      - name: Build application
        run: |
          # Set deployment environment variables
          export DEPLOY_ENV=$DEPLOY_ENV
          export GOOGLE_APPLICATION_CREDENTIALS="$(pwd)/service-account.json"
          export FIREBASE_API_KEY="${{ secrets.FIREBASE_API_KEY }}"
          export FIREBASE_AUTH_DOMAIN="${{ secrets.FIREBASE_AUTH_DOMAIN }}"
          export FIREBASE_PROJECT_ID="$project_id"
          export FIREBASE_STORAGE_BUCKET="${{ secrets.FIREBASE_STORAGE_BUCKET }}"
          export FIREBASE_MESSAGING_SENDER_ID="${{ secrets.FIREBASE_MESSAGING_SENDER_ID }}"
          export FIREBASE_APP_ID="${{ secrets.FIREBASE_APP_ID }}"
          export FIREBASE_MEASUREMENT_ID="${{ secrets.FIREBASE_MEASUREMENT_ID }}"
          export NUXT_PUBLIC_RECAPTCHA_SITE_KEY="$recaptcha_site_key"
          export RECAPTCHA_SECRET_KEY="$recaptcha_secret_key"

          # Build with Firebase preset
          echo "Building for $ENVIRONMENT environment with Firebase preset using Node.js $NODE_VERSION"
          NITRO_PRESET=firebase pnpm build

          # Verify build output
          if [ -d ".output" ]; then
            echo "âœ… Build completed successfully, .output directory exists"
            ls -la .output
          else
            echo "âŒ Build failed, .output directory not found"
            exit 1
          fi

      - name: Prepare functions for deployment
        run: |
          # Update firebase.json to use the correct Node.js runtime version for functions
          # Temporarily use jq to ensure correct JSON manipulation
          apt-get update && apt-get install -y jq
          jq '.functions.runtime = "nodejs18"' firebase.json > firebase.json.tmp && mv firebase.json.tmp firebase.json
          echo "Updated Firebase functions runtime to nodejs18:"
          cat firebase.json

          # Verify Firebase builds
          echo "Checking Firebase deployment files:"
          echo "Hosting files (.output/public):"
          ls -la .output/public || echo "âŒ Public directory not found"

          echo "Functions files (.output/server):"
          ls -la .output/server || echo "âŒ Server directory not found"

          # Check for package.json in server directory
          if [ -f ".output/server/package.json" ]; then
            echo "âœ… Server package.json exists"
            cat .output/server/package.json
          else
            echo "âŒ Server package.json not found"
            # Create a minimal package.json if it doesn't exist
            echo '{"name":"nuxt-ssr-function","version":"1.0.0","engines":{"node":"18"}}' > .output/server/package.json
            echo "Created minimal package.json for functions"
          fi

          # Check for firebase-functions dependency in server/package.json
          if [ -f ".output/server/package.json" ] && ! grep -q "firebase-functions" .output/server/package.json; then
            echo "Adding firebase-functions to server/package.json"
            cd .output/server && npm install --save firebase-functions@^4.0.0
          fi

      - name: Deploy to Firebase
        if: github.event_name == 'push' && (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev' || github.ref == 'refs/heads/development')
        run: |
          export GOOGLE_APPLICATION_CREDENTIALS="$(pwd)/service-account.json"

          # IMPORTANT: Firebase Tools v14.0.0+ dropped support for Node.js 18.
          # We're using v13.35.0 as the last compatible version until we can upgrade to Node 20.
          # The upgrade is currently blocked by compatibility issues between better-sqlite3 and nuxt/content.
          npm install -g firebase-tools@13.35.0

          # Using the service account credentials directly instead of token
          echo "Deploying to Firebase project: $project_id"
          firebase use $project_id

          # First validate the configuration
          firebase deploy --only functions:server,hosting --project $project_id --dry-run

          # Then do the actual deployment
          echo "Starting actual deployment..."
          firebase deploy --only functions:server,hosting --project $project_id

      - name: Deployment confirmation
        if: github.event_name == 'push' && (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev' || github.ref == 'refs/heads/development')
        run: |
          echo "ðŸŽ‰ Deployment completed successfully to $ENVIRONMENT environment"
          echo "Project: $project_id"
          echo "Region: $FIREBASE_REGION"
          echo "Function: server"
          echo "Timestamp: $(date)"

          # Check deployed function
          firebase functions:list --project $project_id
